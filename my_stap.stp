global enter_sys=0;
global retry_path=0;
global sk_store;
//SYSCALL Hooks
probe syscall.mq_notify
{
    if (execname() == "cve"){
        enter_sys = 1;
        printf("[S] (%d - %d) >> MQ_NOTIFY(%s)\n", pid(), tid(), argstr);
    }
}

probe syscall.mq_notify.return
{
    if (execname() == "cve"){
    printf("[S] (%d - %d) << MQ_NOTIFY=%d\n", pid(), tid(), $return);
    enter_sys = 0;
    }
}

//probe syscall.sendmsg
//{
//    if (execname() == "cve"){
 //       printf("[S] (%d - %d) >> SYSCALL_SENDMSG(%s)\n", pid(), tid(), argstr);
   // }
//}

//probe syscall.sendmsg.return
//{
//    if (execname() == "cve"){
//    printf("[S] (%d - %d) << SYSCALL_SENDMSG=%d\n", pid(), tid(), $return);
//    }
//}

probe kernel.function("copy_from_user")
{
    if (execname() == "cve" && enter_sys == 1) 
        printf("[S] (%d - %d) >> COPY_FROM_USER(%s)\n", pid(), tid(), $$parms);
}
probe kernel.function("__audit_mq_notify")
{
    if (execname() == "cve" && enter_sys == 1) 
        printf("[S] (%d - %d) >> __AUDIT_MQ_NOTIFY(%s)\n", pid(), tid(), $$parms);
}

probe kernel.function("__alloc_skb")
{
    if(execname() == "cve" && enter_sys == 1)
        printf("[S] (%d - %d) >> __ALLOC_SKB(%s)\n", pid(), tid(), $$parms);
}

probe kernel.function("__alloc_skb").return
{
    if(execname() == "cve" && enter_sys == 1)
        printf("[S] (%d - %d) << __ALLOC_SKB=0x%x\n", pid(), tid(), $return);
}
probe kernel.function("__fdget")
{
    if(execname() == "cve" && enter_sys == 1)
        printf("[S] (%d - %d) >> __FDGET(%s)\n", pid(), tid(), $$parms);
}
probe kernel.function("__fdget").return
{
    if(execname() == "cve" && enter_sys == 1) {
        printf("[S] (%d - %d) << __FDGET=0x%x\n", pid(), tid(), $return);
        if (retry_path==1)
            printf("This is the RETRY PATH!\n");
    }
}
probe kernel.function("skb_put")
{
    if (execname() == "cve" && enter_sys == 1)
        printf("[S] (%d - %d) >> SKB_PUT(%s)\n", pid(), tid(), $$parms);
}

probe kernel.function("skb_put").return
{
    if (execname() == "cve" && enter_sys == 1)
        printf("[S] (%d - %d) << SKB_PUT=0x%x\n", pid(), tid(), $return);
}

probe kernel.function("netlink_getsockbyfilp")
{
    if (execname() == "cve" && enter_sys == 1)
        printf("[S] (%d - %d) >> NETLINK_GETSOCKBYFILP(%s)\n", pid(), tid(), $$parms);
}

probe kernel.function("netlink_getsockbyfilp").return
{
    if (execname() == "cve" && enter_sys == 1)
        printf("[S] (%d - %d) << NETLINK_GETSOCKBYFILP=0x%x\n", pid(), tid(), $return);
}

probe kernel.function("fput")
{
    if(execname() == "cve" && enter_sys == 1)
        printf("[S] (%d - %d) >> FPUT(%s)\n", pid(), tid(), $$parms);
}

probe kernel.function("netlink_getsockbyfilp").return
{
    if (execname() == "cve" && enter_sys == 1)
        printf("[S] (%d - %d) << FPUT=0x%x\n", pid(), tid(), $return);
}

probe kernel.function("netlink_attachskb")
{
    if(execname() == "cve" && enter_sys == 1){
        printf("[S] (%d - %d) >> NETLINK_ATTACHSKB(%s)\n", pid(), tid(), $$parms);
        dump_netlink_socket($sk);
        sk_store = $sk;
    }
}

probe kernel.function("netlink_attachskb").return
{
    if (execname() == "cve" && enter_sys == 1){
        printf("[S] (%d - %d) << NETLINK_ATTACHSKB=0x%x\n", pid(), tid(), $return);
        if (retry_path == 1)
            $return = 0;
        retry_path = 1;
    }
}
probe kernel.function("netlink_detachskb")
{
    if(execname() == "cve" && enter_sys == 1){
        printf("[S] (%d - %d) >> NETLINK_DETACHSKB(%s)\n", pid(), tid(), $$parms);
    }
}
probe kernel.function("netlink_detachskb").return
{
    if(execname() == "cve" && enter_sys == 1){
        printf("[S] (%d - %d) << NETLINK_DETACHSKB\n", pid(), tid());
        dump_netlink_socket(sk_store);
    }
}
probe kernel.function("netlink_setsockopt")
{
    if(execname() == "cve"){
        printf("[S] (%d - %d) >> NETLINK_SETSOCKOPT(%s)\n", pid(), tid(), $$parms);
    }
}
probe kernel.function("netlink_setsockopt").return
{
    if(execname() == "cve"){
        printf("[S] (%d - %d) << NETLINK_SETSOCKOPT\n", pid(), tid());
    }
}
probe kernel.function("__sk_free")
{
    if(execname() == "cve" && enter_sys == 1){
        printf("[S] (%d - %d) >> __sk_free(%s)\n", pid(), tid(), $$parms);
    }
}
probe kernel.function("__sk_free").return
{
    if(execname() == "cve" && enter_sys == 1){
        printf("[S] (%d - %d) << __SK_FREE\n", pid(), tid());
    }
}
//probe kernel.function("schedule_timeout") {
//    if (execname() == "cve" && enter_sys == 1){
//        printf("[S] (%d-%d) >> SCHEDULE_TIMEOUT(%s)\n", pid(), tid(), $$parms);
//    }
//}
//probe kernel.function("schedule_timeout").return {
//    if (execname() == "cve" && enter_sys == 1){
//        printf("[S] (%d-%d) << SCHEDULE_TIMEOUT=0x%x\n", pid(), tid(), $return);
//    }
//}
//probe kernel.function("netlink_skb_set_owner_r"){
//    if(execname() == "cve"){
//        printf("[S] (%d - %d) << NETLINK_SKB_SET_OWNER_R(%s)\n", pid(), tid(),$$parms);
//    }
//}
//probe kernel.function("netlink_skb_set_owner_r"){
//    if(execname() == "cve"){
//        printf("[S] (%d - %d) << NETLINK_SKB_SET_OWNER_R\n", pid(), tid());
//    }
//}
//
//
//probe kernel.function("netlink_sendmsg"){
//    if(execname() == "cve") {
//        printf("[S] (%d - %d) >> NETLINK_SENDMSG(%s)\n", pid(), tid(), $$parms);
//        dump_sendmsg($msg);
//    }
//}
//probe kernel.function("netlink_sendmsg").return{
//    if(execname() == "cve"){
//        printf("[S] (%d - %d) << NETLINK_SENDMSG=0x%x\n", pid(), tid(), $return);
//    }
//}
//probe kernel.function("netlink_autobind"){
//    if(execname() == "cve") {
//        printf("[S] (%d - %d) >> NETLINK_AUTOBIND(%s)\n", pid(), tid(), $$parms);
//    }
//}
//probe kernel.function("netlink_autobind").return{
//    if(execname() == "cve"){
//        printf("[S] (%d - %d) << NETLINK_AUTOBIND=0x%x\n", pid(), tid(), $return);
//    }
//}
%{
#include <net/sock.h>

struct netlink_sock {
	/* struct sock has to be the first member of netlink_sock */
	struct sock		sk;
	u32			portid;
	u32			dst_portid;
	u32			dst_group;
	u32			flags;
	u32			subscriptions;
	u32			ngroups;
	unsigned long		*groups;
	unsigned long		state;
	size_t			max_recvmsg_len;
	wait_queue_head_t	wait;
	bool			cb_running;
	struct netlink_callback	cb;
	struct mutex		*cb_mutex;
	struct mutex		cb_def_mutex;
	void			(*netlink_rcv)(struct sk_buff *skb);
	int			(*netlink_bind)(int group);
	void			(*netlink_unbind)(int group);
	struct module		*module;
};
%}
function dump_netlink_socket:long (arg_sock:long)
%{
    struct sock *sk = (void*) STAP_ARG_arg_sock;
    struct netlink_sock *nlk = (void*) sk;
    _stp_printf("\n\n-={dump netlink socket: %p}=-\n", nlk);
    _stp_printf("- sk: %p\n", sk);
    _stp_printf("- sk->sk_rmem_alloc: %x\n", sk->sk_rmem_alloc);
    _stp_printf("- sk->sk_rcvbuf: %x\n", sk->sk_rcvbuf);
    _stp_printf("- nlk->state: %d\n", nlk->state);
    //_stp_printf("Before return, change the state in NETLINK_CONGESTED in order to trigger the correct path...\n");
    //nlk->state |= 0x1;
    _stp_printf("- nlk->state: %d\n", nlk->state);
    _stp_printf("- sk->sk_flags: %x\n", sk->sk_flags);
    //_stp_printf("Mark the socket to death in order to wait the wait queue\n");
    //sk->sk_flags |= (1 << SOCK_DEAD);
    //_stp_printf("- sk->sk_flags: %x\n", sk->sk_flags);
    _stp_printf("sk->sk_refcnt: %d\n", sk->sk_refcnt);
    _stp_printf("We are on the waiting queue...\n");
    _stp_printf("\n\n");
%}
